<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Speedcooking</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link href="https://fonts.googleapis.com/css?family=Lora" rel="stylesheet">

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="./d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

    <style>
      svg {
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
      }
    </style>

  </head>
  <body>
    <nav id="nav" class="navbar navbar-dark bg-primary">
      <a class="navbar-brand" href="">SpeedCooking</a>
      <select class="selectRecipes"></select>
    </nav>


    <div class="container">
      <!-- Content here -->
      <svg></svg>
    </div>


    <script>

      var width = 900,
          height = 500,
          margins = {top: 30, right: 20, left: 20, bottom: 20, inter_rect: 0}
          temp_internode_distance = 50,
          padding_right = 30;


      var svg = d3.select("svg")
        .attr("width", width)
        .attr("height", height)

      var select = d3.select("select");

      var recipe_chosen;
      var data_recipe;




      function addLine(x1,y1,x2,y2){
        var bezierLine = d3.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .curve(d3.curveBasis);

        //points intermediaires
        var x_int1 = x1*(2/3) + x2*(1/3);
        var y_int1 = y1;
        var x_int2 = x1*(1/3) + x2*(2/3);
        var y_int2 = y2;
/*     x1     x_int1
        x       x

                        x       x
                     x_int2     x2            */
        svg.append('path')
            .attr("d", bezierLine([[x1,y1],[x_int1,y_int1],[x_int2,y_int2],[x2,y2]]))
            .attr("stroke", "red")
            .attr("stroke-width", 1)
            .attr("fill", "none");
      };

      function drawTree(etapes){
        // on suppose que les champs x et y sont déjà définis pour chaque étape
        for(var i=0; i< etapes.length; i++){
          var children = etapes[i].enfants;
          var xp = etapes[i].x;
          var yp = etapes[i].y;
          children.forEach(function (c) {
            var xc = etapes[c].x;
            var yc = etapes[c].y;
            addLine(xp,yp,xc,yc);
          });
        };
      };

      //Calcul de profondeur
      var set_and_get_depth = function (i,etapes){
       d = 1;
       var children = etapes[i].enfants;
       var children_depths = []
       var j = 0;
       children.forEach(function (c) {
         children_depths[j] = set_and_get_depth(c,etapes);
         j++ ;
       });
       var d_c = Math.max.apply(null, children_depths) +1;
       if (d_c > d) {
         d = d_c;
       };
       // setting the depths for the children
       etapes[i].depth = d;
       return d;
      };



      //Ajout de TOUS les lieux dans une liste
      var get_lieux = function (etapes){
       //console.log("inputs");
       //console.log(i);

       lieux = [];
       var children = etapes[i].enfants;
       children.forEach(function (c) {
         l_c = get_lieux(c,etapes);
         //console.log("children:");
         //console.log(l_c);
         //console.log("+");
         //console.log(lieux);
         a = fusion(lieux,l_c);
         //console.log(lieux);
         lieux = Object.create(a);
         //console.log("after fusion");
         //console.log(lieux);
       });
       lieux = fusion(lieux,[{"lieu":etapes[i].lieu}]);
       return lieux;
     };

      var color = d3.scaleOrdinal(d3.schemePastel1);

      d3.json("recettes.json", function(json) {

        data_recipe = json.recettes[0];
        // on en aura besoin avant de changer le form



        // Load the recipe chosen in the LOCAL variable data_recipe.
        select.on("change", function(){
            recipe_chosen = d3.select(".selectRecipes").node().value;

            // Put info with selected information.
            for (var i = 0; i< json.recettes.length; i++){
              if (json.recettes[i].nom == recipe_chosen) {
                data_recipe = json.recettes[i]
              }
            }
        });

        // Add all recipe chosen in the dropdown.
        select.selectAll("option").data(json.recettes).enter()
          .append("option")
          .attr("value", function(d) {return d.nom})
          .html(function(d) {return d.nom})




        // ajout des valeurs en x et y

        // x : calcul de profondeur
        /*var get_depth = function (i,etapes){
          d = 1;
          //console.log("call withb i=");
          //console.log(i);
          var children = etapes[i].enfants;
          children.forEach(function (c) {
            d_c = get_depth(c,etapes);
            if (d_c+1 > d) {
              d = d_c+1;
            }
          });
          //console.log("return :");
          //console.log(d);
          return d;
        };
        depth = get_depth(data_recipe.etapes.length-1,data_recipe.etapes);


        //console.log(depth);*/




        // choix de localisation des lieux :
        // On commence par chercher un four. S'il y en a un, on le met au dessus

        var locations_obj = [];
        var lieux_visites = [];
        for (var i=0; i<data_recipe.etapes.length; i++){
          console.log(data_recipe.etapes[i].lieux);
          if (data_recipe.etapes[i].lieu == 'four'){
            locations_obj[0] = {lieu: "four", id: 1};
            lieux_visites[0] = "four";
          };
        };

        // Ensuite, on parcourt les étapes pour y ajouter les lieux
        var id_min = locations_obj.length;  // 1 si n a ajoute le four, 0 sinon

        for (var i=0; i<data_recipe.etapes.length; i++){
          var lieu = data_recipe.etapes[i].lieu;
          if (! lieux_visites.includes(lieu)) {
            locations_obj[id_min] = {lieu: lieu, id: id_min+1};
            lieux_visites[id_min] = lieu;
            id_min++;
          };
        };

        console.log(locations_obj);
/*
        var locations_obj = [{lieu: "plan de travail 1", id: 4},
        {lieu: "plaque de cuisson 1", id: 2},
        {lieu: "plan de travail 2", id: 3},
        {lieu: "four", id: 1},
        {lieu: "plan de travail 3", id: 5}]

        locations_obj.sort(function(a, b) {
          return a.id - b.id;
        });

*/

        // Create background for locations (four, plaque de travail 1, ...)
        var heigth_rect = (height - margins.top - margins.bottom) / locations_obj.length;

        locations = svg.selectAll(".locations").data(locations_obj).enter()
          .append("g")
            .attr("class", "locations")
            .attr("transform", function(d, i) {
              var translateY = parseInt(margins.top) + i*(heigth_rect + margins.inter_rect);
              return "translate(" + margins.left + "," + translateY + ")"
            })

        locations.append("rect")
          .attr("class", function(d){return d.lieu})
          .attr("width", function(){return width - margins.right - margins.left})
          .attr("height", function(d){return heigth_rect})
          .attr("x", 0)
          .attr("y", 0)
          .attr("fill", function(d,i){
            //console.log(i%2)
            if (i%2 !== 0){
              return "#eee"
            } else {
              return "#bbb"
            }
          })
          .style("opacity", 0.5)

        locations.append("text")
          .style("font-weight", "bold")
          .attr("class", "location_title")
          .attr("transform", function(d, i) {
            return "translate(3,18)"
          })
          .html(function(d){return capitalize(d.lieu)})


        // Store strings of locations in all_locations
        var all_locations = []
        data_recipe.etapes.forEach(function(d,i){
          if (!all_locations.includes(d.lieu)){
            all_locations.push(d.lieu)
          }
        })

        // Add in location_obj the nodes classified.
        locations_obj.forEach(function(location,j){
            location.etapes = [];
          })

        data_recipe.etapes.forEach(function(etape,i){
          locations_obj.forEach(function(location,j){
            if (location.lieu === etape.lieu){
              location.etapes.push(etape.identifiant)
            }
          })
        })


        //console.log(data_recipe.etapes)
        var max_depth = set_and_get_depth(data_recipe.etapes.length-1,data_recipe.etapes);

        Scale_x = d3.scaleLinear() // prend en entrée les profondeurs, et renvoie les x
        .domain([0,max_depth+1])
        .range([margins.left,width-margins.right]);


        var nodes = svg.selectAll(".node").data(data_recipe.etapes).enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", function(d){

            // Get the id of the y position of the node.
            for (var ind = 0; ind < locations_obj.length; ind++){
              if (locations_obj[ind].lieu === d.lieu){
                var y_index = locations_obj[ind].id;
              }
            }
            // Get the x position of the node in the grid


            var x = Scale_x(d.depth);
            d.x = x;
            var y = margins.top + (heigth_rect + margins.inter_rect) * (y_index - 1/2);
            d.y = y;
            return "translate(" + x + "," + y + ")"
          })

        drawTree(data_recipe.etapes);

        nodes.append('rect')
          .attr("width", "10")
          .attr("height", "10")
          .attr("fill", "red")

        nodes.append("text")
          .html(function(d){
            return d.identifiant + ": " + capitalize(d.description_courte)
          })



        //console.log(data_recipe)
        //console.log(locations_obj)




      })



    function capitalize(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    </script>


  </body>
</html>
