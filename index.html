<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Speedcooking</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link href="https://fonts.googleapis.com/css?family=Lora" rel="stylesheet">

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="./d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-color.v1.min.js"></script>
    <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

    <style>
      svg {
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
      }
    </style>


    <!-- Tooltip style -->
    <style>
        .hidden {
            display: none;
        }

        div.tooltip {
            color: #222;
            background-color: #fff;
            padding: .5em;
            text-shadow: #f5f5f5 0 1px 0;
            border-radius: 2px;
            opacity: 0.9;
            position: absolute;
        }
    </style>

  </head>
  <body>
    <nav id="nav" class="navbar navbar-dark bg-primary">
      <a class="navbar-brand" href="">SpeedCooking</a>
      <select class="selectRecipes"></select>
    </nav>


    <div class="container">
      <!-- Content here -->
      <svg></svg>
    </div>


    <script>

      var width = 900,
          height = 500,
          margins = {top: 30, right: 20, left: 20, bottom: 20, inter_rect: 0}
          temp_internode_distance = 50,
          padding_right = 30;

      var size_node = 10;

      var svg = d3.select("svg")
        .attr("width", width)
        .attr("height", height)

      var select = d3.select("select");

      var recipe_chosen;
      var data_recipe;


      var selectedNode = -1;


      var tooltip = d3.select('body').append('div')
        .attr('class', 'hidden tooltip');


      function addLine(x1,y1,x2,y2){
        var bezierLine = d3.line()
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .curve(d3.curveBasis);

        //points intermediaires
        var x_int1 = x1*(2/3) + x2*(1/3);
        var y_int1 = y1;
        var x_int2 = x1*(1/3) + x2*(2/3);
        var y_int2 = y2;
      /*     x1     x_int1
        x       x

                        x       x
                     x_int2     x2            */
        svg.append('path')
            .attr("d", bezierLine([[x1,y1],[x_int1,y_int1],[x_int2,y_int2],[x2,y2]]))
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("fill", "none");
      };

      function drawTree(etapes){
        // on suppose que les champs x et y sont déjà définis pour chaque étape
        for(var i=0; i< etapes.length; i++){
          var children = etapes[i].enfants;
          var xp = etapes[i].x - size_node/2;
          var yp = etapes[i].y;
          children.forEach(function (c) {
            var xc = etapes[c].x + size_node/2;
            var yc = etapes[c].y;
            console.log(i,etapes[i].depth)
            console.log(c,etapes[c].depth)
            if (etapes[i].depth > etapes[c].depth+1){
              var delta_depth = etapes[i].depth - etapes[c].depth;
              var new_xc = (xc-xp)/delta_depth + xp;
              addLine(xp,yp,new_xc,yc);
              addLine(new_xc,yc,xc,yc); // ligne droite jusqu'au virage

            } else {
              addLine(xp,yp,xc,yc);
            };
          });
        };
      };

      //Calcul de profondeur
      var set_and_get_depth = function (i,etapes){
       var children_depths = [];
       etapes[i].enfants.forEach(function (c) {
         children_depths.push(set_and_get_depth(c,etapes));
       });
       var d_c = Math.max.apply(null, children_depths) + 1;
       var d = 1;
       if (d_c > d) {
         d = d_c;
       };
       // setting the depths for the children
       etapes[i].depth = d;
       return d;
      };



      //Ajout de TOUS les lieux dans une liste
      var get_lieux = function (etapes){
       //console.log("inputs");
       //console.log(i);

       var lieux = [];
       var children = etapes[i].enfants;
       children.forEach(function (c) {
         var l_c = get_lieux(c,etapes);
         //console.log("children:");
         //console.log(l_c);
         //console.log("+");
         //console.log(lieux);
         var a = fusion(lieux,l_c);
         //console.log(lieux);
         lieux = Object.create(a);
         //console.log("after fusion");
         //console.log(lieux);
       });
       lieux = fusion(lieux,[{"lieu":etapes[i].lieu}]);
       return lieux;
      };

      var color = d3.scaleOrdinal(d3.schemePastel1);

      d3.json("recettes.json", function(json) {

        data_recipe = json.recettes[2];
        // on en aura besoin avant de changer le form

        // Load the recipe chosen in the LOCAL variable data_recipe.
        select.on("change", function(){
            recipe_chosen = d3.select(".selectRecipes").node().value;

            // Put info with selected information.
            for (var i = 0; i< json.recettes.length; i++){
              if (json.recettes[i].nom == recipe_chosen) {
                data_recipe = json.recettes[i]
              }
            }
        });

        // Add all recipe chosen in the dropdown.
        select.selectAll("option").data(json.recettes).enter()
          .append("option")
          .attr("value", function(d) {return d.nom})
          .html(function(d) {return d.nom})


        // choix de localisation des lieux :
        // On commence par chercher un four. S'il y en a un, on le met au dessus

        var locations_obj = [];
        var lieux_visites = [];
        for (var i=0; i<data_recipe.etapes.length; i++){
          console.log(data_recipe.etapes[i].lieux);
          if (data_recipe.etapes[i].lieu == 'four'){
            locations_obj[0] = {lieu: "four", id: 1};
            lieux_visites[0] = "four";
          };
        };

        // Ensuite, on parcourt les étapes pour y ajouter les lieux
        var id_min = locations_obj.length;  // 1 si n a ajoute le four, 0 sinon

        for (var i=0; i<data_recipe.etapes.length; i++){
          var lieu = data_recipe.etapes[i].lieu;
          if (! lieux_visites.includes(lieu)) {
            locations_obj[id_min] = {lieu: lieu, id: id_min+1};
            lieux_visites[id_min] = lieu;
            id_min++;
          };
        };

        console.log(locations_obj);
        /*
        var locations_obj = [{lieu: "plan de travail 1", id: 4},
        {lieu: "plaque de cuisson 1", id: 2},
        {lieu: "plan de travail 2", id: 3},
        {lieu: "four", id: 1},
        {lieu: "plan de travail 3", id: 5}]

        locations_obj.sort(function(a, b) {
          return a.id - b.id;
        });
        */

        // Create background for locations (four, plaque de travail 1, ...)
        var heigth_rect = (height - margins.top - margins.bottom) / locations_obj.length;

        locations = svg.selectAll(".locations").data(locations_obj).enter()
          .append("g")
            .attr("class", "locations")
            .attr("transform", function(d, i) {
              var translateY = parseInt(margins.top) + i*(heigth_rect + margins.inter_rect);
              return "translate(" + margins.left + "," + translateY + ")"
            })

        locations.append("rect")
          .attr("class", function(d){return d.lieu})
          .attr("width", function(){return width - margins.right - margins.left})
          .attr("height", function(d){return heigth_rect})
          .attr("x", 0)
          .attr("y", 0)
          .attr("fill", function(d,i){
            //console.log(i%2)
            if (i%2 !== 0){
              return "#eee"
            } else {
              return "#bbb"
            }
          })
          .style("opacity", 0.5)

        locations.append("text")
          .style("font-weight", "bold")
          .attr("class", "location_title")
          .attr("transform", function(d, i) {
            return "translate(3,18)"
          })
          .html(function(d){return capitalize(d.lieu)})


        // Store strings of locations in all_locations
        var all_locations = []
        data_recipe.etapes.forEach(function(d,i){
          if (!all_locations.includes(d.lieu)){
            all_locations.push(d.lieu)
          }
        })

        // Add in location_obj the nodes classified.
        locations_obj.forEach(function(location,j){
            location.etapes = [];
          })

        data_recipe.etapes.forEach(function(etape,i){
          locations_obj.forEach(function(location,j){
            if (location.lieu === etape.lieu){
              location.etapes.push(etape.identifiant)
            }
          })
        })


        //console.log(data_recipe.etapes)
        var max_depth = set_and_get_depth(data_recipe.etapes.length-1,data_recipe.etapes);

        scale_x = d3.scaleLinear() // prend en entrée les profondeurs, et renvoie les x
          .domain([0, max_depth + 1])
          .range([margins.left,width-margins.right]);


        var nodes = svg.selectAll(".node").data(data_recipe.etapes).enter()
          .append("g")
          .attr("class", "node")
          .attr("id", function(d){
            return "node_" + d.identifiant
          })
          .attr("transform", function(d){
            // Get the x position of the node in the grid
            var x = scale_x(d.depth);
            d.x = x;
            d.x_index = d.depth;

            // Get the id of the y position of the node.
            var y_index;
            for (var ind = 0; ind < locations_obj.length; ind++){
              if (locations_obj[ind].lieu === d.lieu){
                y_index = locations_obj[ind].id;
              }
            }
            var y = margins.top + (heigth_rect + margins.inter_rect) * (y_index - 1/2);
            d.y = y;
            d.y_index = y_index
            return "translate(" + x + "," + y + ")"
          })


        nodes.append('rect')
          .attr("transform", function(){
            return "translate(" + (-size_node/2) + "," + (-size_node/2) + ")"
          })
          .attr("width", size_node)
          .attr("height", size_node)
          .attr("fill", "red")

        nodes.append("text")
          .html(function(d){
            return capitalize(d.description_courte) + " (" + d.identifiant + ")"
          })
          .attr("transform", function(){
          	return "translate(" + (-size_node) + "," + (-size_node) + ")"
          })

        drawTree(data_recipe.etapes);



        function getNextNode(selectedNode, direction){
          //var x_index_source = data_recipe.etapes[selectedNode].x_index
          //    y_index_source = data_recipe.etapes[selectedNode].y_index;

          //console.log(x_index_source, y_index_source)

           switch (direction){
            case 37: //gauche
              if (selectedNode >= 1){
                selectedNode -= 1
              } else {
                selectedNode = -1
              }
              break
            case 38: // haut

              break
            case 39: // Droite.
              if (selectedNode < data_recipe.etapes.length - 1){
                selectedNode += 1
              } else {
                selectedNode = -1
              }
              break
            case 40: // Bas
              break
          }
          return selectedNode
        }


        d3.select('body').on("keydown", function(d) {

          if (selectedNode === -1){
            // Do nothing
          } else {
            // Remove old green node.
            nodes.selectAll("g#node_" + selectedNode + " > rect")
              .transition()
              .attr("fill", 'red')
              .attr("transform", function(){
                return "translate(" + (-size_node/2) + "," + (-size_node/2) + ")"
              })
              .attr("width", size_node)
              .attr("height", size_node)

            //Hide tooltip
            hideTooltip()
          }

          selectedNode = getNextNode(selectedNode, d3.event.keyCode)

          if (selectedNode === -1){
            // Do nothing
          } else {
            nodes.selectAll("g#node_" + selectedNode + " > rect")
              .transition()
              .attr("fill", 'green')
              .attr("transform", "translate(" + (-size_node) + "," + (-size_node) + ")")

              .attr("width", size_node*2)
              .attr("height", size_node*2)

            showTooltip(data_recipe.etapes[selectedNode].x - 50, data_recipe.etapes[selectedNode].y + 50)
          }
        })


        function showTooltip(x, y){
          tooltip
            .classed('hidden', false)
            .attr('style', 'left:' + x + 'px; top:' + y + 'px')
            .html(function(){
              return data_recipe.etapes[selectedNode].description_longue
            })
        }

        function hideTooltip(){
          tooltip
            .classed('hidden', true)
        }


      })



      function capitalize(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }

    </script>
  </body>
</html>
